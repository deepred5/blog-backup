---
title: 前端开发中的一些容易被忽略的概念
date: 2018-04-12 15:16:26
tags: [前端]
---
工作也有一段时间了，平时忙于业务代码的编写中，发现身边的一些人以及自己，对一些基本概念理解有所偏差，可能会闹出笑话，会问出下面这些常识性错误的奇怪问题：
1. [vuejs怎么在服务器部署？](https://www.zhihu.com/question/46630687)
2. [vue开发的项目，前端写的.vue文件中的生命周期方法，线上还存在吗？](https://www.zhihu.com/question/68570658)

2333，怎么都是关于Vue的问题。。。我真没黑Vue开发者，不过也可以看出，Vue的小白受众的确比较多。

## webpack和webpack-dev-server
现在基于Vue，React的SPA单页应用开发，都倾向于采用webpack的模块化构建方案。可能大多数人，开发一个项目，会使用脚手架工具（vue-cli, create-react-app）
我们本地开发时，运行命令行`npm run dev`，然后就开始编写业务逻辑了，对于其中发生了什么，大多数人可能不太关心。其实运行了该命令，就是运行了`webpack-dev-server` 

webpack-dev-server是webpack官方提供的一个小型Express服务器，正是因为webpack-dev-server自己开启了一个服务器，我们才能够前后端分离开发(我们不需要关心后端的代码)。前端启动的这个服务器，是用来构建和渲染页面，并提供了自动刷新和热替换功能。

简单来说：
webpack只是构建(`npm run build`)
webpack-dev-server除了构建，还提供web服务(`npm run dev`)

## 路由
什么是路由？
简单来说：`/about/deepred` `/home/` 这些就是路由

在web开发中，路由分为前端路由和后台路由
其实在单页应用还没有流行前，路由基本指的是后台路由。如果你熟悉传统的后台web开发，可能对下面的代码很熟悉：
```javascript
app.get('/about', function (req, res) {
  res.render('about', { title: 'Hey', message: 'Hello there!'});
});
app.get('/', function (req, res) {
  res.render('index');
});
```
传统的web网站，所有的路由都是由后台定义的。当我们想访问一个页面`http://anata.me/about/`，首先向后台发送一个请求，后台根据定义好的路由，决定渲染哪个页面。

然而单页应用的出现，改变了这个模式。如果你是前端开发，应该对这段代码更加熟悉：
```javascript
routes: [
    {
      path: '/user/:userId',
      name: 'user',
      component: User
    },
    {
      path: '/about/',
      name: 'about',
      component: About
    }
  ]
```
前端路由是将页面的渲染权交给了js控制，不通过请求服务器来判断渲染页面。前端一般利用histroy和hash来控制，达到不刷新页面可以使显示内容发生变化，这样速度更快，用户体验更好。前端路由解放了服务端，专心提供接口数据服务。

## 打包部署
脚手架生成的项目，一般运行`npm run build`之后，会在项目根目录生成一个dist目录，这就是我们打包好后的静态资源文件。
**注意的是**：
1. 我们线上运行的单页应用，就是打包好后的dist文件，并不是src目录下的源文件
2. 线上部署更不是运行`npm run dev`启动项目。`npm run dev`启动的服务器只是为了开发而使用的，真正线上的服务器，是由后台提供的（比如PHP，Java, python, Node...）

部署的方式有很多，比如可以把dist文件和后台代码放在一起，后台把dist文件当做静态资源读取即可。不过因为采用了前端路由的方案，后台还需要配置一下，以Express举例：
```javascript
// 访问静态资源文件 这里是访问所有dist目录下的静态资源文件
app.use(express.static(path.resolve(__dirname, '../dist')))
// 因为是单页应用 所有请求都走/dist/index.html
// 这一句要放在所有其他路由的后面
app.get('*', function(req, res) {
    const html = fs.readFileSync(path.resolve(__dirname, '../dist/index.html'), 'utf-8')
    res.send(html)
})
```
也可以把dist静态文件和后台代码分开，通过Nginx部署
```
server {
        listen 80;
        server_name 127.0.0.1;
        location / {
            root   /data/deered/dist; # 前端打包后的dist文件位置
            try_files $uri $uri/ /index.html;
            index  index.html;
        }
    }
```

## 跨域
因为webpack-dev-server启动了一个服务器，所以在开发时，前端去请求真正的后台接口，是存在跨域问题的。webpack提供了跨域的解决方案，原理就是让服务器反向代理请求真正的接口

vue-cli配置跨域
```javascript
proxyTable: {
      '/api': {
        target: 'http://localhost:8089/api/',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    },
```
前端请求`/api/xxxx`时，webpack-dev-server启动的服务器会帮我们请求`http://localhost:8089/api/xxxx`，同时返回数据。

有些人就会有疑惑，那打包后的文件，是不是也能跨域。前面我们说了，线上部署就不是运行`npm run dev`，所以，前端是不是跨域要看你怎么部署了。

如果你把打包后的dist文件和后端代码放在一起，那么根本就不存在跨域问题！
如果前端静态文件和后端不在一起，那么可以用Nginx做转发
```
server {
        listen 80;
        server_name 127.0.0.1;
        location / {
            root   /data/deered/dist; # 前端打包后的dist文件位置
            index  index.html;
        }
        location /api {
            include  uwsgi_params;
            proxy_pass http://127.0.0.1:8089/api
        }
    }
```